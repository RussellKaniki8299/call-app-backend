import React, { useRef, useEffect, useState } from "react";
import { io } from "socket.io-client";
import { Phone, PhoneOff, Video, VideoOff, Mic, MicOff, Volume2 } from "react-feather";

const socket = io("https://call-app-backend-kqzr.onrender.com");

const styles = {
  container: { width: "100vw", height: "100vh", backgroundColor: "#121212", color: "white", display: "flex", flexDirection: "column", justifyContent: "space-between", fontFamily: "sans-serif" },
  videoGrid: { display: "grid", gap: "10px", padding: "10px", flexGrow: 1, gridTemplateColumns: "repeat(auto-fit, minmax(200px, 1fr))" },
  videoWrapper: { position: "relative", borderRadius: "12px", overflow: "hidden", boxShadow: "0 2px 10px rgba(0,0,0,0.5)" },
  video: { width: "100%", height: "100%", objectFit: "cover", borderRadius: "12px" },
  localLabel: { position: "absolute", bottom: "8px", left: "8px", backgroundColor: "rgba(0,0,0,0.5)", padding: "2px 6px", borderRadius: "6px", fontSize: "12px" },
  controls: { position: "fixed", bottom: "20px", left: "50%", transform: "translateX(-50%)", display: "flex", gap: "20px", backgroundColor: "rgba(0,0,0,0.3)", padding: "15px 20px", borderRadius: "50px", alignItems: "center", boxShadow: "0 2px 20px rgba(0,0,0,0.5)" },
  button: { width: "60px", height: "60px", borderRadius: "50%", border: "none", display: "flex", justifyContent: "center", alignItems: "center", cursor: "pointer", transition: "all 0.2s", fontSize: "24px" },
  activeCall: { backgroundColor: "red", color: "white" },
  inactiveCall: { backgroundColor: "#25D366", color: "white" },
  toggleBtn: { backgroundColor: "#eee", color: "#333" },
};

function App() {
  const [localStream, setLocalStream] = useState(null);
  const [peers, setPeers] = useState({});
  const [callActive, setCallActive] = useState(false);
  const [micOn, setMicOn] = useState(true);
  const [cameraOn, setCameraOn] = useState(true);

  const localVideo = useRef();
  const pcs = useRef({});

  useEffect(() => {
    // Quand un nouvel utilisateur rejoint
    socket.on("user-joined", async (userId) => {
      if (!localStream) return;
      const pc = createPeerConnection(userId);
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit("offer", { offer, to: userId });
    });

    // RÃ©ception d'une offre
    socket.on("offer", async ({ offer, from }) => {
      if (!localStream) return;
      const pc = createPeerConnection(from);
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      await pc.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      socket.emit("answer", { answer, to: from });
    });

    // RÃ©ception d'une answer
    socket.on("answer", async ({ answer, from }) => {
      const pc = pcs.current[from];
      if (pc) {
        if (pc.signalingState === "have-local-offer") {
          await pc.setRemoteDescription(new RTCSessionDescription(answer));
        } else {
          console.warn("Answer reÃ§ue mais PC n'est pas en have-local-offer:", pc.signalingState);
        }
      }
    });

    // RÃ©ception de candidats ICE
    socket.on("ice-candidate", async ({ candidate, from }) => {
      const pc = pcs.current[from];
      if (pc && candidate) await pc.addIceCandidate(new RTCIceCandidate(candidate));
    });

    // Un utilisateur quitte
    socket.on("user-left", (userId) => {
      if (pcs.current[userId]) pcs.current[userId].close();
      setPeers(prev => {
        const copy = { ...prev };
        delete copy[userId];
        return copy;
      });
      delete pcs.current[userId];
    });
  }, [localStream]);

  // Assigner le flux local Ã  la vidÃ©o locale
  useEffect(() => {
    if (localVideo.current && localStream) {
      localVideo.current.srcObject = localStream;
      localVideo.current.muted = true; // mute pour ne pas s'entendre
    }
  }, [localStream]);

  const createPeerConnection = (socketId) => {
    const pc = new RTCPeerConnection();
    pcs.current[socketId] = pc;

    pc.ontrack = (event) => {
      setPeers(prev => ({ ...prev, [socketId]: event.streams[0] }));
    };

    pc.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit("ice-candidate", { candidate: event.candidate, to: socketId });
      }
    };

    return pc;
  };

  const startCall = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      setLocalStream(stream);
      setCallActive(true);
      socket.emit("join-room");
    } catch (err) {
      alert("âš ï¸ Autorise camÃ©ra et micro !");
      console.error(err);
    }
  };

  const endCall = () => {
    localStream?.getTracks().forEach(track => track.stop());
    setLocalStream(null);
    setCallActive(false);
    Object.values(pcs.current).forEach(pc => pc.close());
    pcs.current = {};
    setPeers({});
    socket.emit("leave-room");
  };

  const toggleMic = () => {
    localStream.getAudioTracks()[0].enabled = !micOn;
    setMicOn(!micOn);
  };

  const toggleCamera = () => {
    localStream.getVideoTracks()[0].enabled = !cameraOn;
    setCameraOn(!cameraOn);
  };

  return (
    <div style={styles.container}>
      <div style={styles.videoGrid}>
        {localStream && (
          <div style={styles.videoWrapper}>
            <video ref={localVideo} autoPlay playsInline style={styles.video} />
            <div style={styles.localLabel}>Vous</div>
          </div>
        )}

        {Object.entries(peers).map(([id, stream]) => (
          <PeerVideo key={id} stream={stream} />
        ))}
      </div>

      <div style={styles.controls}>
        {callActive ? (
          <>
            <ControlButton onClick={endCall} style={styles.activeCall}><PhoneOff size={28} /></ControlButton>
            <ControlButton onClick={toggleMic} style={styles.toggleBtn}>{micOn ? <Mic size={24} /> : <MicOff size={24} />}</ControlButton>
            <ControlButton onClick={toggleCamera} style={styles.toggleBtn}>{cameraOn ? <Video size={24} /> : <VideoOff size={24} />}</ControlButton>
            <ControlButton style={styles.toggleBtn}><Volume2 size={24} /></ControlButton>
          </>
        ) : (
          <ControlButton onClick={startCall} style={styles.inactiveCall}><Phone size={28} /></ControlButton>
        )}
      </div>
    </div>
  );
}

// VidÃ©o des autres utilisateurs
function PeerVideo({ stream }) {
  const videoRef = useRef();

  useEffect(() => {
    if (videoRef.current && stream) {
      videoRef.current.srcObject = stream;
      videoRef.current.muted = false;
    }
  }, [stream]);

  return (
    <div style={{ position: "relative", borderRadius: "12px", overflow: "hidden", boxShadow: "0 2px 10px rgba(0,0,0,0.5)" }}>
      <video ref={videoRef} autoPlay playsInline style={{ width: "100%", height: "100%", objectFit: "cover", borderRadius: "12px" }} />
    </div>
  );
}

// Bouton flottant avec effet hover
function ControlButton({ children, onClick, style }) {
  const [hover, setHover] = useState(false);
  return (
    <button
      onClick={onClick}
      style={{ ...style, width: "60px", height: "60px", borderRadius: "50%", display: "flex", justifyContent: "center", alignItems: "center", cursor: "pointer", transform: hover ? "scale(1.1)" : "scale(1)", transition: "all 0.2s" }}
      onMouseEnter={() => setHover(true)}
      onMouseLeave={() => setHover(false)}
    >
      {children}
    </button>
  );
}

export default App;


const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const cors = require("cors");

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, { cors: { origin: "*" } });

const rooms = {}; // idRoom => [socketId]

io.on("connection", (socket) => {
  console.log("âœ… Utilisateur connectÃ©:", socket.id);

  socket.on("join-room", () => {
    socket.join("main");
    socket.to("main").emit("user-joined", socket.id);
  });

  socket.on("leave-room", () => {
    socket.to("main").emit("user-left", socket.id);
    socket.leave("main");
  });

  socket.on("offer", ({ offer, to }) => {
    io.to(to).emit("offer", { offer, from: socket.id });
  });

  socket.on("answer", ({ answer, to }) => {
    io.to(to).emit("answer", { answer, from: socket.id });
  });

  socket.on("ice-candidate", ({ candidate, to }) => {
    io.to(to).emit("ice-candidate", { candidate, from: socket.id });
  });

  socket.on("disconnect", () => {
    socket.to("main").emit("user-left", socket.id);
    console.log("âŒ Utilisateur dÃ©connectÃ©:", socket.id);
  });
});

server.listen(5000, () => console.log("ðŸš€ Serveur en Ã©coute sur http://localhost:5000"));
