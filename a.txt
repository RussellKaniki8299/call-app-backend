import React, { useRef, useEffect, useState } from "react";
import { io } from "socket.io-client";

const socket = io("https://call-app-backend-kqzr.onrender.com");

function App() {
  const localVideo = useRef(null);
  const remoteVideo = useRef(null);
  const pc = useRef(null);

  const [hasPermissions, setHasPermissions] = useState(null);

  useEffect(() => {
    // VÃ©rifier les permissions dÃ©jÃ  donnÃ©es
    if (navigator.permissions) {
      navigator.permissions.query({ name: "camera" }).then((result) => {
        console.log("Permission camÃ©ra :", result.state);
      }).catch(() => {});
      navigator.permissions.query({ name: "microphone" }).then((result) => {
        console.log("Permission micro :", result.state);
      }).catch(() => {});
    }

    // CÃ´tÃ© callee : rÃ©ception d'une offre
    socket.on("offer", async (offer) => {
      if (!pc.current) createPeerConnection();

      try {
        console.log("Signaling state avant setRemoteDescription:", pc.current.signalingState);
        await pc.current.setRemoteDescription(new RTCSessionDescription(offer));

        const answer = await pc.current.createAnswer();
        await pc.current.setLocalDescription(answer);
        socket.emit("answer", answer);
      } catch (err) {
        console.error("Erreur lors du traitement de l'offre:", err);
      }
    });

    // CÃ´tÃ© caller : rÃ©ception d'une answer
    socket.on("answer", async (answer) => {
      try {
        if (pc.current && pc.current.signalingState === "have-local-offer") {
          console.log("Signaling state avant setRemoteDescription(answer):", pc.current.signalingState);
          await pc.current.setRemoteDescription(new RTCSessionDescription(answer));
        } else {
          console.warn("RÃ©ponse reÃ§ue dans un mauvais Ã©tat :", pc.current?.signalingState);
        }
      } catch (err) {
        console.error("Erreur lors de la rÃ©ception de l'answer:", err);
      }
    });

    // Candidats ICE
    socket.on("ice-candidate", async (candidate) => {
      try {
        if (pc.current) {
          await pc.current.addIceCandidate(new RTCIceCandidate(candidate));
        }
      } catch (e) {
        console.error("Erreur ICE", e);
      }
    });
  }, []);

  const createPeerConnection = () => {
    pc.current = new RTCPeerConnection();

    pc.current.ontrack = (event) => {
      remoteVideo.current.srcObject = event.streams[0];
    };

    pc.current.onicecandidate = (event) => {
      if (event.candidate) {
        socket.emit("ice-candidate", event.candidate);
      }
    };
  };

  const startCall = async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      setHasPermissions(true);

      localVideo.current.srcObject = stream;

      if (!pc.current) createPeerConnection();

      stream.getTracks().forEach((track) => pc.current.addTrack(track, stream));

      // CrÃ©ation de l'offre
      const offer = await pc.current.createOffer();
      await pc.current.setLocalDescription(offer);
      socket.emit("offer", offer);
    } catch (err) {
      console.error("Erreur getUserMedia:", err.name, err.message);
      setHasPermissions(false);
      alert("âš ï¸ Autorise lâ€™accÃ¨s camÃ©ra/micro dans ton navigateur !");
    }
  };

  return (
    <div style={{ textAlign: "center", marginTop: "2rem" }}>
      <h1>ğŸ“¹ Prototype Appel VidÃ©o</h1>
      <div style={{ display: "flex", justifyContent: "center", gap: "1rem" }}>
        <video ref={localVideo} autoPlay muted playsInline style={{ width: "300px", border: "1px solid black" }} />
        <video ref={remoteVideo} autoPlay playsInline style={{ width: "300px", border: "1px solid black" }} />
      </div>
      <button onClick={startCall} style={{ marginTop: "1rem", padding: "10px 20px" }}>
        ğŸ“ DÃ©marrer l'appel
      </button>
      {hasPermissions === false && (
        <p style={{ color: "red", marginTop: "1rem" }}>
          âŒ CamÃ©ra/Micro bloquÃ©s. Clique sur lâ€™icÃ´ne ğŸ”’ en haut du navigateur et autorise-les.
        </p>
      )}
    </div>
  );
}

export default App;  

const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const cors = require("cors");

const app = express();
app.use(cors());

const server = http.createServer(app);

const io = new Server(server, {
  cors: { origin: "*" },
});

io.on("connection", (socket) => {
  console.log("âœ… Un utilisateur est connectÃ©:", socket.id);

  socket.on("offer", (data) => {
    socket.broadcast.emit("offer", data);
  });

  socket.on("answer", (data) => {
    socket.broadcast.emit("answer", data);
  });

  socket.on("ice-candidate", (data) => {
    socket.broadcast.emit("ice-candidate", data);
  });

  socket.on("disconnect", () => {
    console.log("âŒ Utilisateur dÃ©connectÃ©:", socket.id);
  });
});

server.listen(5000, () => {
  console.log("ğŸš€ Serveur en Ã©coute sur http://localhost:5000");
});  hebrgÃ© sur render le front est ailleurs. Ã§a marche bien. mais je veux que Ã§a soit vraiment pro l'utilisateur doit choisir le type d'appel(audio ou video) donc avec les icones react-feather et quand il appelle un utilisateur on doit passer aussi l'id de cet utilisateur donc on doit donner Ã  chacun un id et si on l'appelle il doit voir les boutons accepter et refuser, si il accetpe alors l'appelle commence, je veux vraiment que Ã§a soit profesionnel comme whatsapp parce que lÃ , on risque d'avoir l'impression qu'on appelle tout utilisateur connectÃ© alors qu'il faut preciser; par exemple l'utilisateur avec id 178 appelle celui qui a id 100 ou vice versa et signaler aussi si l'appelÃ© a deja un appel en cours